import numpy as np
import re
from datetime import datetime
import os
from pathlib import Path

## SETUP
Ep = '2.00'
file_name = f'Li_source_Epmin_0_Epmax_{Ep}.cpp'
file_path = f"fuente_LiMetal_Epmin_0_Epmax_{Ep}/sdef_LiMetal_Epmin_0_Epmax_{Ep}"

new_source_path = f"fuente_LiMetal_Epmin_0_Epmax_{Ep}/src/{file_name}"
cmake_path = f"fuente_LiMetal_Epmin_0_Epmax_{Ep}/src/CMakeLists.txt"

def getEnergyData():

    si_list = []
    sp_list = []
    si = False
    sp = False
    # Open file
    with open(file_path) as input_file:

        # Get each line in file and split into list, delimited by spaces
        for line in input_file:
            line_list = line.split()

            if line_list[0] == f'si999':
                si = True

            elif line_list[0] == f'sp999':
                si = False
                sp = True
            
            elif line_list[0] == 'ds998' and sp == True:

                si = False
                sp = False
                break

            if si == True:
                si_list += line_list
            
            elif sp == True:
                sp_list += line_list
    
    energies = np.asarray(si_list[2:], dtype=float)
    intensities = np.asarray(sp_list[1:], dtype = float)

    normed_intensities = intensities / np.sum(intensities)
    energies = energies * 1e6
    
    return energies, normed_intensities

def getEnergyBins():

    ds_list = []
    ds = False

    # Open file
    with open(file_path) as input_file:

        # Get each line in file and split into list, delimited by spaces
        for line in input_file:
            line_list = line.split()

            if line_list[0] == f'ds998':
                ds = True
            
            elif line_list[0] == 'c' and ds == True:
                ds = False
                break

            if ds == True:
                ds_list += line_list


    edges = np.asarray(ds_list[2::2], dtype=float) * 1e6

    return edges


def getAngularData(n):

    si_list = []
    sp_list = []
    si = False
    sp = False
    # Open file
    with open(file_path) as input_file:

        # Get each line in file and split into list, delimited by spaces
        for line in input_file:
            line_list = line.split()

            if line_list[0] == f'si{n}':
                si = True

            elif line_list[0] == f'sp{n}':
                si = False
                sp = True
            
            elif line_list[0] == 'c' and sp == True:

                si = False
                sp = False
                break

            if si == True:
                si_list += line_list
            
            elif sp == True:
                sp_list += line_list

    angles = np.asarray(si_list[2:], dtype=float)
    intensities = np.asarray(sp_list[1:], dtype = float)
    normed_intensities = intensities / np.sum(intensities)

    return angles, normed_intensities


def getParticleWeight():

    # Open file
    with open(file_path) as input_file:

        # Get each line in file and split into list, delimited by spaces
        for line in input_file:
            #line_list = line.split()

            if re.search('^wgt=', line.strip()):
                
                weight = line.strip()[4:]
                break
    
    return weight

# Code needs to get 
# Energy distribution
E_values, E_probabilities = getEnergyData()


# Edges for angular distribution selection
E_angle_select_edges = getEnergyBins()
E_angle_select_edges_with_0 = np.insert(E_angle_select_edges, 0, 0)
print(E_angle_select_edges_with_0)

# Define the number of angular distributions
N_ang_dists = len(E_angle_select_edges)

# Angular distributions
# Iterate through and get each angular distribution
angular_distributions = []
for n in range(N_ang_dists):

    # List of format [[[cos(ang)], [prob]], [cos(ang)], [prob]], ...]
    # So we select the distribution with first index, and then values and probability from second index
    # e.g. angular_distributions[0][0] gives si1, angular_distributions[0][1] gives sp1
    angular_distributions.append(getAngularData(n+1))

# Get weight of particle
particle_weight = getParticleWeight()


# Now have all data, need to write to a C++ file

# Comments at start of code about how it was written
author_comments = f'/*\nSource file for OpenMC generated by MCNP_to_OpenMC.py script by Max Conroy.\
    \n\nDistributions based on MCNP SDEF file by Daniel Minsky.\
    \n\nDetails:\n\tGenerated on {datetime.now().strftime("%d-%m-%Y")}.\
    \n\nFor more information, please contact m.j.conroy@pgr.bham.ac.uk.\n*/\n'

#  Define includes needed for C++ file
includes = ['<memory>', '<cmath>', '<vector>', '<iostream>', '"openmc/random_lcg.h"', '"openmc/source.h"',
             '"openmc/particle.h"', '"openmc/distribution.h"']

class_name = 'Li_source'

# Create class and sample function as required by OpenMc
class_create = f'\n// Create new source class which inherits from openmc::Source\
    \nclass {class_name} : public openmc::Source {{\n'
function_define = '\n\t// Define a function called "sample" to generate neutrons\n\topenmc::SourceSite sample(uint64_t* seed) const {\n'
function_details_1 = f'\n\t\topenmc::SourceSite particle;\n\t\t// Define particle type\n\t\tparticle.particle = openmc::ParticleType::neutron;\
    \n\t\t// Define particle weight\n\t\tparticle.wgt = {particle_weight};\n' # {particle_weight}

# Initialise required variables
var_init = f'\n\t\t// Initialise required variables\
    \n\t\tdouble energy {{0.0}};\n\t\tdouble mu {{0.0}};\
    \n\t\tdouble theta {{0.0}};\n\t\tdouble phi {{0.0}};\
    \n\t\tdouble pos_r {{0.0}};\n\t\tdouble pos_ang {{0.0}};\n'

# Define energy distribution
E_dist_values = f'\n\t\t// Define energies and probabilities for distribution\
    \n\t\tdouble energies[{len(E_values)}] = {{{np.array2string(E_values, separator=",")[1:-1]}}};\
    \n\t\tdouble E_probabilities[{len(E_probabilities)}] = {{{np.array2string(E_probabilities, separator=",")[1:-1]}}};\n'
E_dist_define = f'\t\t// Define energy distribution\n\t\topenmc::Tabular E_dist(energies, E_probabilities, {len(E_values)}, openmc::Interpolation::lin_lin);\n'
E_dist_sample = f'\t\t// Sample energy from distribution\n\t\tenergy = E_dist.sample(seed);\n\t\tparticle.E = energy;\n'

# Define bin edges for selecting angular distribution
E_edges_values = f'\n\t\t// Define energy values for bin edges to choose angular distribution\
    \n\t\tdouble edges[{len(E_angle_select_edges)}] = {{{np.array2string(E_angle_select_edges, separator=",")[1:-1]}}};\n'

# Create vector to hold angular distributions
create_vec = f'\n\t\t// Create vector to hold angular distributions\
        \n\t\tstd::vector<openmc::Tabular> ang_dists;\n'

# Choose angular distribution
ang_dist_select = f'\n\t\t// Choose angular distribution depending on sampled energy\
    \n\t\tfor (int n = 0; n < {len(E_angle_select_edges)}; n++) {{\
    \n\t\t\tif (energy < edges[n]) {{ \
    \n\t\t\t\tmu = ang_dists[n].sample(seed);\
    \n\t\t\t\tbreak;\n\t\t\t}}\n\t\t}}\n'\
    #    \n\t\t\t\tstd::cout << n << " : " << energy << " : " << mu << std::endl;\

# Convert mu to directional vector and calc and set ux, uy, uz
direction = f'\n\t\t// Convert sampled mu to angle\
    \n\t\ttheta = std::acos(mu);\
    \n\t\t// Sample phi in range [0,2pi];\
    \n\t\tphi = 2.0 * M_PI * openmc::prn(seed);\
    \n\n\t\t// Set directional vector\
    \n\t\tparticle.u = {{std::sin(theta)*std::cos(phi), std::sin(theta)*std::sin(phi), mu}};\n'

# Set position of particle
position = '\n\t\t// Sample particle starting position\
\n\t\topenmc::PowerLaw r_dist(0, 5, 1);\
    \n\t\tpos_r = r_dist.sample(seed);\
    \n\t\tpos_ang = 2.0 * M_PI * openmc::prn(seed);\
    \n\t\t// Set position of particle\
    \n\t\tparticle.r = {pos_r*std::cos(pos_ang), pos_r*std::sin(pos_ang) - 4.2, 0.0};\n'
    #\t\t\tstd::cout << particle.r << std::endl;'

# Return particle and close brackets
return_particle = '\n\t\t// Return particle\
    \n\t\treturn particle;\
    \n\t}\
    \n};\n'

# Footer, to create unique pointer 
footer = f'\n// Function to create unique pointer to an instance of this class when generated via a plugin call using dlopen/dlsym\
    \nextern "C" std::unique_ptr<{class_name}> openmc_create_source(std::string parameters) {{\
    \n\treturn std::make_unique<{class_name}>();\
    \n}}'

# Create src directory
Path(f"fuente_LiMetal_Epmin_0_Epmax_{Ep}/src").mkdir(parents=True, exist_ok=True)

# Write C++ file for source
with open(new_source_path, 'w') as file:

    file.write(author_comments)

    for i in includes:
        file.write(f'#include {i}\n')

    file.write(class_create)
    file.write(function_define)
    file.write(function_details_1)
    file.write(var_init)
    file.write(E_dist_values)
    file.write(E_dist_define)
    file.write(E_dist_sample)
    file.write(E_edges_values)
    file.write(create_vec)
    

    for i, dist in enumerate(angular_distributions):
        ang_dist = f'\n\t\t// Angular distribution for energies {E_angle_select_edges_with_0[i]} < E <= {E_angle_select_edges_with_0[i+1]}\
            \n\t\tdouble cos_angles_{i+1}[{len(dist[0])}] = {{{np.array2string(dist[0], separator=",")[1:-1]}}};\
            \n\t\tdouble ang_probabilities_{i+1}[{len(dist[0])}] = {{{np.array2string(dist[1], separator=",")[1:-1]}}};\
            \n\t\topenmc::Tabular ang_dist_{i+1}(cos_angles_{i+1}, ang_probabilities_{i+1}, {len(dist[0])}, openmc::Interpolation::lin_lin);\
            \n\t\tang_dists.push_back(ang_dist_{i+1});\n'

        file.write(ang_dist)

    file.write(ang_dist_select)

    file.write(direction)
    file.write(position)
    file.write(return_particle)
    file.write(footer)

# Write CMAKE file
with open(cmake_path, 'w') as file:

    file.write('cmake_minimum_required(VERSION 3.3 FATAL_ERROR)\
               \nproject(openmc_sources CXX)\n')
    file.write(f'add_library(source SHARED {file_name})\n')
    file.write('find_package(OpenMC REQUIRED HINTS $ENV{CONDA_PREFIX}/lib64/cmake/OpenMC)\
               \ntarget_link_libraries(source OpenMC::libopenmc)')
    
# Make build directory
Path(f"fuente_LiMetal_Epmin_0_Epmax_{Ep}/build").mkdir(parents=True, exist_ok=True)

# Run cmake command in build directory
os.system(f'cd fuente_LiMetal_Epmin_0_Epmax_{Ep}/build && cmake ../src')

# Run make to compile source
os.system(f'cd fuente_LiMetal_Epmin_0_Epmax_{Ep}/build && make')
